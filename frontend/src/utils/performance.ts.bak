// Frontend Performance Optimization Utilities
import React from 'react';

/**
 * Lazy load a component
 */
export function lazyLoad(
  importFunc: () => Promise<{ default: React.ComponentType<any> }>
) {
  return React.lazy(importFunc);
}

/**
 * Preload a component for faster rendering
 */
export function preloadComponent(importFunc: () => Promise<any>) {
  // Start importing immediately without waiting
  importFunc().catch(() => {
    // Silently fail
  });
}

/**
 * Create a timeout wrapper for async operations
 */
export function withTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number,
  timeoutMessage: string = 'Operation timed out'
): Promise<T> {
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      reject(new Error(timeoutMessage));
    }, timeoutMs);

    promise
      .then((result) => {
        clearTimeout(timeoutId);
        resolve(result);
      })
      .catch((error) => {
        clearTimeout(timeoutId);
        reject(error);
      });
  });
}

/**
 * Memoize expensive calculations
 */
export function memoize<T extends (...args: any[]) => any>(
  fn: T,
  keyGenerator?: (...args: Parameters<T>) => string
): T {
  const cache = new Map<string, ReturnType<T>>();

  return ((...args: Parameters<T>): ReturnType<T>) => {
    const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);

    if (cache.has(key)) {
      return cache.get(key)!;
    }

    const result = fn(...args);
    cache.set(key, result);

    // Limit cache size
    if (cache.size > 100) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }

    return result;
  }) as T;
}

/**
 * Batch multiple state updates to reduce re-renders
 */
export function batchUpdates<T>(updates: (() => T)[]): T[] {
  const results: T[] = [];
  updates.forEach(update => {
    results.push(update());
  });
  return results;
}

/**
 * Create an intersection observer for lazy loading
 */
export function createIntersectionObserver(
  callback: (entries: IntersectionObserverEntry[]) => void,
  options: IntersectionObserverInit = {}
) {
  const defaultOptions: IntersectionObserverInit = {
    root: null,
    rootMargin: '50px',
    threshold: 0.1,
    ...options
  };

  return new IntersectionObserver(callback, defaultOptions);
}

/**
 * Virtual scrolling for large lists
 */
export class VirtualList<T> {
  private itemHeight: number;
  private containerHeight: number;
  private overscan: number;
  private data: T[];
  private scrollTop: number = 0;

  constructor(
    data: T[],
    itemHeight: number,
    containerHeight: number,
    overscan: number = 5
  ) {
    this.data = data;
    this.itemHeight = itemHeight;
    this.containerHeight = containerHeight;
    this.overscan = overscan;
  }

  getTotalHeight(): number {
    return this.data.length * this.itemHeight;
  }

  getVisibleRange() {
    const startIndex = Math.floor(this.scrollTop / this.itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(this.containerHeight / this.itemHeight) + this.overscan,
      this.data.length - 1
    );

    return {
      startIndex: Math.max(0, startIndex - this.overscan),
      endIndex,
      visibleItems: this.data.slice(
        Math.max(0, startIndex - this.overscan),
        endIndex + 1
      )
    };
  }

  setScrollTop(scrollTop: number) {
    this.scrollTop = scrollTop;
  }

  getOffsetY(): number {
    const startIndex = Math.floor(this.scrollTop / this.itemHeight);
    return startIndex * this.itemHeight;
  }
}

/**
 * Image lazy loading with intersection observer
 */
export function lazyLoadImage(
  img: HTMLImageElement,
  src: string,
  placeholder?: string
) {
  if (placeholder) {
    img.src = placeholder;
  }

  const observer = createIntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        img.src = src;
        observer.unobserve(img);
      }
    });
  });

  observer.observe(img);
}

/**
 * Resource preloader
 */
export class ResourcePreloader {
  private cache = new Map<string, Promise<any>>();

  preload(url: string, type: 'image' | 'script' | 'style' = 'image'): Promise<any> {
    if (this.cache.has(url)) {
      return this.cache.get(url)!;
    }

    let promise: Promise<any>;

    switch (type) {
      case 'image':
        promise = new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = url;
        });
        break;

      case 'script':
        promise = new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = url;
          script.onload = () => resolve(script);
          script.onerror = reject;
          document.head.appendChild(script);
        });
        break;

      case 'style':
        promise = new Promise((resolve, reject) => {
          const link = document.createElement('link');
          link.rel = 'stylesheet';
          link.href = url;
          link.onload = () => resolve(link);
          link.onerror = reject;
          document.head.appendChild(link);
        });
        break;

      default:
        promise = Promise.reject(new Error('Invalid resource type'));
    }

    this.cache.set(url, promise);
    return promise;
  }

  clear() {
    this.cache.clear();
  }
}

/**
 * Debounce function for events
 */
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null;

  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      timeout = null;
      func(...args);
    };

    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/**
 * Throttle function for events
 */
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean;

  return function executedFunction(...args: Parameters<T>) {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

/**
 * Measure render time
 */
export function measureRenderTime(
  componentName: string,
  fn: () => void
): void {
  if (process.env.NODE_ENV !== 'production') {
    const start = performance.now();
    fn();
    const end = performance.now();
    console.log(`${componentName} render time: ${end - start}ms`);
  } else {
    fn();
  }
}

/**
 * Measure async operation time
 */
export async function measureAsyncTime<T>(
  operationName: string,
  fn: () => Promise<T>
): Promise<T> {
  const start = performance.now();
  try {
    const result = await fn();
    const end = performance.now();
    console.log(`${operationName} completed in ${end - start}ms`);
    return result;
  } catch (error) {
    const end = performance.now();
    console.error(`${operationName} failed after ${end - start}ms`, error);
    throw error;
  }
}

/**
 * Request idle callback polyfill
 */
export function requestIdleCallback(
  callback: (deadline: {
    timeRemaining: () => number;
    didTimeout: boolean;
  }) => void,
  options?: { timeout: number }
): number {
  if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {
    return window.requestIdleCallback(callback, options);
  }

  return window.setTimeout(() => {
    callback({
      timeRemaining: () => Math.max(0, 50 - (performance.now() % 50)),
      didTimeout: false
    });
  }, 1);
}

/**
 * Cancel idle callback
 */
export function cancelIdleCallback(id: number): void {
  if (typeof window !== 'undefined' && 'cancelIdleCallback' in window) {
    window.cancelIdleCallback(id);
  } else {
    clearTimeout(id);
  }
}

/**
 * Load data in chunks to prevent blocking
 */
export async function loadInChunks<T>(
  data: T[],
  chunkSize: number,
  processor: (chunk: T[]) => Promise<void>,
  onProgress?: (progress: number) => void
): Promise<void> {
  const totalChunks = Math.ceil(data.length / chunkSize);

  for (let i = 0; i < totalChunks; i++) {
    const start = i * chunkSize;
    const end = Math.min(start + chunkSize, data.length);
    const chunk = data.slice(start, end);

    await processor(chunk);

    if (onProgress) {
      onProgress((i + 1) / totalChunks);
    }

    // Yield to the event loop to prevent blocking
    await new Promise(resolve => setTimeout(resolve, 0));
  }
}

/**
 * Optimize bundle size by dynamically importing heavy dependencies
 */
export async function loadHeavyDependency() {
  const heavyModule = await import('heavy-dependency');
  return heavyModule;
}

/**
 * Cache API responses
 */
export class APICache {
  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();
  private defaultTTL = 5 * 60 * 1000; // 5 minutes

  async get(key: string): Promise<any | null> {
    const cached = this.cache.get(key);
    if (!cached) return null;

    if (Date.now() - cached.timestamp > cached.ttl) {
      this.cache.delete(key);
      return null;
    }

    return cached.data;
  }

  set(key: string, data: any, ttl?: number): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl: ttl || this.defaultTTL
    });

    // Clean up old entries
    if (this.cache.size > 100) {
      this.cleanup();
    }
  }

  cleanup(): void {
    const now = Date.now();
    for (const [key, value] of this.cache.entries()) {
      if (now - value.timestamp > value.ttl) {
        this.cache.delete(key);
      }
    }
  }

  clear(): void {
    this.cache.clear();
  }
}

export const apiCache = new APICache();

/**
 * Performance observer for monitoring
 */
export function observePerformance(
  callback: (entry: PerformanceEntry) => void
): PerformanceObserver | null {
  if (typeof window !== 'undefined' && 'PerformanceObserver' in window) {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach(callback);
    });
    observer.observe({ entryTypes: ['measure', 'navigation', 'paint'] });
    return observer;
  }
  return null;
}

/**
 * Get performance metrics
 */
export function getPerformanceMetrics() {
  if (typeof window === 'undefined' || !('performance' in window)) {
    return null;
  }

  const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;

  return {
    dns: navigation.domainLookupEnd - navigation.domainLookupStart,
    tcp: navigation.connectEnd - navigation.connectStart,
    ttfb: navigation.responseStart - navigation.requestStart,
    download: navigation.responseEnd - navigation.responseStart,
    dom: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
    load: navigation.loadEventEnd - navigation.loadEventStart,
    total: navigation.loadEventEnd - navigation.navigationStart
  };
}
